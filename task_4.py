# Вычислить число π c заданной точностью d

# *Пример:* 

# - при $d = 0.001, π = 3.141.$    $10^{-1} ≤ d ≤10^{-10}$

# .
# https://completerepair.ru/kak-vychislit-chislo-pi

# ******************* Decicion:
# def calculate_pi():
#     pi = 3.1415926535897932384626433832795
#     capacity = int(input('введите желаемую разрядность числа Pi после запятой: '))
#     print(round(pi, capacity))


# calculate_pi()

# **************************************
# .
# .
# 2 Задайте натуральное число N. Напишите программу, которая составит список простых множителей числа N.

# *Пример*

# - при N=236     ->        [2, 2, 59]

# ******************* Decicion:

#  перебрать все числа от 0 до Н/2. Если число искомое число делиться без остатка, то проверить является ли оно простым. если да, то 

# def list_of_prime_factors(n):
#     lst_simple_number = []
#     for i in range(1, int (n / 2)):                 #перебираем цикл от 1 до половины введенного числа
#         if n % i == 0:                              #если число делиться без остатка на элемент цикла, то рассматриваем его как потенциально простое и делаем соответствующую проверку
#             count = 0
#             for x in range(1, int(n + 1)):          #проверка числа - простое или нет
#                 if i % x == 0:                      #если число i делиться без остатка на элемент цикла, то к переменной count прибавляется 1
#                     count += 1
#             if count == 2:                          #если после перебора цикла переменная count = 2 (то есть налось только два делителя на цело),то это число является простым
#                 n = n / i                           #переменную n уменьшаем (делим на простое число)
#                 lst_simple_number.append(i)         #добавляем найденное простое число в результирующий список
#                                                     #проверяем, делиться ли новое значение n еще раз на это простое число
#                 if n % i == 0:                      #если делится, то еще раз добавляем в результирующий список
#                     lst_simple_number.append(i)
#                     n = n / i
#                                                     #иначе идем дальше по итерируемому списку (увеличиваем i на единицу)
#     print(lst_simple_number)

# list_of_prime_factors(236)

# *************************************************************

# .
# .
# 3 Задайте последовательность чисел. Напишите программу, которая выведет список неповторяющихся элементов исходной последовательности.

# *Пример*

# - при [1, 1, 2, 3, 3, 4, 1, 5, 7, 8, 8, 7, 9]     ->        [2, 4, 5, 9]


# ******************* Decicion:

# def f():
#     lst = input('введите список числе через запятую: ').split(',')
#     no_dublicate = [int(i) for i in lst if lst.count(i) == 1]
#     print(no_dublicate)

# f()

# *************************************************

# .
# .
# 4 Задана натуральная степень k. Сформировать случайным образом список коэффициентов (значения от 0 до 100) многочлена и записать в файл многочлен степени k.

# *Пример:* 

# - k=2 => 2*x² + 4*x + 5 = 0 или x² + 5 = 0 или 10*x² = 0

# ******************* Decicion:
import random

def write_polynome(k, file_name):                  # в качестве аргументов в функцию подставляются степень многочлена "k" и название будущего файла
    # k = int(input('введите степень: '))
    res = ''
    for i in range(k, -1, -1):
        a_i = random.randint(0, 100)               # образование коэффициента у соответствующего элемента многочлена
        if a_i != 0 and i > 0:
            res += f'{a_i}x**{i} + '               # если коэфф !=0 и элемент многочлена не крайний, то к результирующей строке добавляется такой элемент
        elif i == 0:
            res += str(a_i)                        # если элемент многочлена крайний, то к результирующей строке добавляется такой элемент
        else:
            res += ''                              # если коэфф a_i=0, то к результирующей строке ничего не добавляется
    res += ' = 0'
    with open(f'{file_name}.txt', 'w') as file:
        file.write(res)

# write_polynome(2, 'result')
        
        



# .
# .
# 5 Даны два файла, в каждом из которых находится запись многочлена. Задача - сформировать файл, содержащий сумму многочленов.
# Коэффициенты могут быть как положительными, так и отрицательными. Степени многочленов могут отличаться.

# ******************* Decicion:
# Сам чувствую, что намудрил крепко, одни "костыли", но вроде работает)
# для работы программы нужно раскомментировать решение четвертой задачи


import re
write_polynome(2, 'str_1')
write_polynome(5, 'str_2')

with open('str_1.txt', 'r') as file:
    input_1 = file.read()

with open('str_2.txt', 'r') as file:
    input_2 = file.read()

def f(str):                                                             # функция для формирования из искомой строки списка элементов многочлена
    match = re.findall(r'(?:[+-]? ?\d+x\*\*\d+)|(?:\d+[^0])', str)      # при помощи регулярки создать список из элементов многочлена (левая часть равенства)
    res = []                                                            # для формирования результирующего списка элементов многочлена
    for el in match:                                                    # для каждого элемента получившегося списка
        # print(el)
        factor = re.findall(r'[+-]?.?\d+[^x ]', el)                     # с помощью регулярки фиксируем в форме списка коэффициенты при каждом элементе многочлена
        # print('length:', len(el_x))
        factor_int = int(''.join(factor).replace(' ', ''))              # переводим коэффициент из списка в строку (убирая пробел между знаком и числом), затем приводим коэффициент к числу
        degree = re.findall(r'x\*\*\d+', el)                            # с помощью регулярки фиксируем степень каждого одночлена в виде "х**n"
        degree_str = ''.join(degree)
        monomial= [factor_int, degree_str]                              # формируем член многочлена
        res.append(monomial)                                            # добавляет в список очередной сформированный элемент
    # print(to_str, type(to_str))
    return res


lst_polynom_1 = f(input_1)                                              #список элементов 1-го многочлена
lst_polynom_2 = f(input_2)                                              #список элементов 2-го многочлена
# ************** условие для сложения списков - первым идет список с большим кол-вом элементов
res_polynom = []

if len(lst_polynom_1) >= len(lst_polynom_2):
    res_polynom  = lst_polynom_1 + lst_polynom_2
    range_value = len(res_polynom ) - len(lst_polynom_2)
else:
    res_polynom  = lst_polynom_2 + lst_polynom_1
    range_value = len(res_polynom ) - len(lst_polynom_1)

# print('res_polynom : ',res_polynom )

res_fin = []                                                            # итоговый список членов многочлена  суммы

# ************** сложение коэффициентов многочлена с одинаковой степенью и запись в итоговый список

for i in range(range_value):                                            # крайний элемент для перебора в списке (для исключения появления в )
    coincidence = True
    for j in range(i + 1, len(res_polynom )):
        if res_polynom [i][1] == res_polynom [j][1]:
            res_fin.append([res_polynom [i][0] + res_polynom [j][0], res_polynom [i][1]])
            coincidence = True
            break
        else:
            coincidence = False
    if coincidence == False:
        res_fin.append(res_polynom [i])


# **************************************

# print(res_fin)

res_polynome = []
for i in res_fin:
    # args = str(i[0]) + i[1]
    args = f'{i[0]}{i[1]}'

    res_polynome.append(args)
result = ' + '.join(res_polynome) + ' = 0'

# print(res_polynome)
# print(result)

with open('result_polynome.txt','w') as file:
    file.write(result)





